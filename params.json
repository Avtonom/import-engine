{"name":"Import-engine","tagline":"Full-blown importer stack for importing almost any data into your application","body":"Mathielen Import Engine\r\n=============\r\n\r\n[![Build Status](https://travis-ci.org/mathielen/import-engine.png?branch=master)](https://travis-ci.org/mathielen/import-engine) \r\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/mathielen/import-engine/badges/quality-score.png?s=c0a55ac5381a3f8fdacd95eeacc5e5ad8926695f)](https://scrutinizer-ci.com/g/mathielen/import-engine/)\r\n[![Code Coverage](https://scrutinizer-ci.com/g/mathielen/import-engine/badges/coverage.png?s=5f083d5500d3ec956d5fc86a8570a97e2bb9c6dd)](https://scrutinizer-ci.com/g/mathielen/import-engine/)\r\n[![SensioLabsInsight](https://insight.sensiolabs.com/projects/985f7541-2ef9-4b92-98d3-8cf7f4144e74/mini.png)](https://insight.sensiolabs.com/projects/985f7541-2ef9-4b92-98d3-8cf7f4144e74)\r\n[![Latest Stable Version](https://poser.pugx.org/mathielen/import-engine/v/stable.png)](https://packagist.org/packages/mathielen/import-engine)\r\n\r\nFull-blown importer stack for importing almost any data into your application. Can be used for exports, too.\r\n\r\nIntroduction\r\n------------\r\nThis library implements some high-level functionality based on the great [Ddeboer Data Import library](https://github.com/ddeboer/data-import).\r\nAs the Data-Import library offers a great toolkit to implement a data import/export process in a quick and clean way, there is still a lot of work to do to have a full blown importer set up for your application. This library helps you with that.\r\n\r\nIf you are developing a Symfony2 project, you may want to use the comfortable configuration of the [ImportEngineBundle](https://github.com/mathielen/ImportEngineBundle).\r\n\r\nFeatures\r\n--------\r\n* A Storage Abstraction-layer that supports nice features like [automatic delimiter-discovering](#automatic-csv-delimiter-discovery-for-filestorageproviders) or processing compressed files. Currently these storages are supported:\r\n  * Structured Files\r\n    * CSV, XML, JSON, Excel\r\n    * File may be compressed\r\n  * Doctrine2 queries\r\n  * Service endpoints\r\n* Storage Provisioning. Provide a list of possible storage-containers for your import. I.e. local files, remote files, uploaded files, database connections, service endpoints and more.\r\n* A mapping sub-system, for building various mappings for your import: field-field, field-converter-field, field-converter-object and more.\r\n* Automatic mapping into object tree's using the [JMSSerializer](http://jmsyst.com/libs/serializer)\r\n* Source (read) and Target (write) validation using [Symfony Validation](http://symfony.com/doc/current/book/validation.html). Annotations can be used.\r\n* Integrated Eventsystem using [Symfony EventDispatcher](http://symfony.com/doc/current/components/event_dispatcher/introduction.html)\r\n* Keeping almost every flexibility that is offered by the Ddeboer Data Import library.\r\n* Well-tested code.\r\n\r\nInstallation\r\n------------\r\n\r\nThis library is available on [Packagist](https://packagist.org/packages/mathielen/import-engine).\r\nThe recommended way to install it is through [Composer](http://getcomposer.org):\r\n\r\n```bash\r\n$ composer require mathielen/import-engine\r\n```\r\n\r\nThen include Composerâ€™s autoloader:\r\n\r\n```php\r\nrequire_once 'vendor/autoload.php';\r\n```\r\n\r\nQuickstart\r\n----\r\n\r\n#### Import an arbitrary file into your system\r\nUsing the *Provider facilities enables you to let the importer-system figure out what format the file has and what abstraction-classes should be used. \r\n```php\r\n$service = new TestEntities\\Dummy(); //your domain service\r\n\r\n$fileStorageProvider = new Mathielen\\ImportEngine\\Storage\\Provider\\FileStorageProvider();\r\n$storageSelection = $fileStorageProvider->select('tests/metadata/testfiles/flatdata.csv');\r\n$sourceStorage = $fileStorageProvider->storage($storageSelection);\r\n\r\n$targetStorage = new Mathielen\\ImportEngine\\Storage\\ServiceStorage(array($service, 'onNewData'));\r\n$importer = Mathielen\\ImportEngine\\Importer\\Importer::build($targetStorage);\r\n\r\n$import = Mathielen\\ImportEngine\\Import\\Import::build($importer, $sourceStorage);\r\n\r\n$importRunner = new Mathielen\\ImportEngine\\Import\\Run\\ImportRunner();\r\n$importRunner->run($import);\r\n```\r\n\r\n#### More examples\r\nHave a look at: https://github.com/mathielen/import-engine/tree/master/tests/functional/Mathielen/ImportEngine\r\n\r\nUsage\r\n-----\r\n\r\n### Terminology\r\n* An [Importer](#importer) is the basic definition of the whole import-process. It says _what_ may be imported and _where_ to. It consists of:\r\n  * (optional) A [StorageProvider](#storageprovider), that represents a \"virtual file system\" for selecting a SourceStorage\r\n  * (optional) A [SourceStorage](#storage) that may be a file, a database table, an array, an object-tree, etc\r\n  * A [TargetStorage](#storage) that may be a file, a database table, an array, an object-tree, etc\r\n  * A [Mapping](#mapping), which may contain converters, field-mappings, etc\r\n  * A [Validation](#validation), that may contain validation-rules for data read from the SourceStorage and/or validation-rules for data that will be written to the TargetStorage.\r\n  * An [Eventsystem](#eventsystem) for implementing detailed [Logging](#eventsystem) or other interactions within the process.\r\n* An [Import](#import) is a specific definition of the import-process. It uses the [Importer](#importer) and has all the specific informations that is mandatory for processing the data. That is a specific SourceStorage and a [Mapping](#mapping).\r\n* The [ImportRunner](#importrunner) is used to process the Import.\r\n* Every run of an Import is represented by an [ImportRun](#importrun)\r\n\r\n### StorageProvider\r\nStorageProviders represents a \"virtual file system\" for selecting a [SourceStorage](#storage) that can be used as a source or target of the import.\r\n\r\n#### FinderFileStorageProvider\r\nUsing the [Symfony Finder Component](http://symfony.com/doc/current/components/finder.html) as a collection of possible files that can be imported.\r\n\r\n```php\r\nuse Symfony\\Component\\Finder\\Finder;\r\nuse Mathielen\\ImportEngine\\Storage\\Provider\\FinderFileStorageProvider;\r\n\r\n$finder = Finder::create()\r\n  ->in('tests/metadata/testfiles')\r\n  ->name('*.csv')\r\n  ->name('*.tab')\r\n  ->size('>0K')\r\n;\r\n  \r\n$ffsp = new FinderFileStorageProvider($finder);\r\n```\r\n\r\n#### DoctrineQueryStorageProvider\r\nYou can use specific Doctrine Queries or only Entity-Classnames (the query will be SELECT * FROM <Entity> then) as possible Source-Storages.\r\n\r\n```php\r\nuse Symfony\\Component\\Finder\\Finder;\r\nuse Mathielen\\ImportEngine\\Storage\\Provider\\DoctrineQueryStorageProvider;\r\n\r\n$em = ... //Doctrine2 EntityManager\r\n$qb = $em->createQueryBuilder()\r\n  ->select('a')\r\n  ->from('MySystem\\Entity\\Address', 'a')\r\n  ->andWhere('a.id > 10')\r\n;\r\n\r\n$queries = array(\r\n  'MySystem/Entity/MyEntity',\r\n  $qb\r\n);\r\n\r\n$desp = new DoctrineQueryStorageProvider($em, $queries);\r\n```\r\n\r\n#### UploadFileStorageProvider\r\nYou can use a Provider to facilitate a File-Upload.\r\n\r\n```php\r\nuse Mathielen\\ImportEngine\\Storage\\Provider\\UploadFileStorageProvider;\r\n\r\n$ufsp = new UploadFileStorageProvider('/tmp'); //path to where the uploaded files will be transferred to\r\n```\r\n\r\n#### Automatic CSV Delimiter Discovery for FileStorageProviders\r\nFileStorageProviders may use StorageFactories for constructing Storage objects. By default the FormatDiscoverLocalFileStorageFactory is used. This StorageFactory uses a MimeTypeDiscoverStrategy to determine the mime-type of the selected file and use it to create the correct storage-handler. You can change this behavior or extend it. There is a CsvAutoDelimiterTypeFactory that you can use to automaticly guess the correct delimiter of a CSV file.\r\n\r\n```php\r\nuse Mathielen\\ImportEngine\\Storage\\Format\\Factory\\CsvAutoDelimiterFormatFactory;\r\nuse Mathielen\\ImportEngine\\Storage\\Factory\\FormatDiscoverLocalFileStorageFactory;\r\nuse Mathielen\\ImportEngine\\Storage\\Format\\Discovery\\MimeTypeDiscoverStrategy;\r\n\r\n$ffsp = ...\r\n$ffsp->setStorageFactory(\r\n  new FormatDiscoverLocalFileStorageFactory(\r\n    new MimeTypeDiscoverStrategy(array(\r\n      'text/plain' => new CsvAutoDelimiterFormatFactory()\r\n))));\r\n```\r\nThis way any file that has the text/plain mime-type will be passed to the CsvAutoDelimiterFormatFactory to determine the delimiter.\r\n\r\n### Storage\r\nA storage is a container of data. Storages provide a reader and writer implementation for itself.\r\n\r\n```php\r\nuse Mathielen\\ImportEngine\\Storage\\ArrayStorage;\r\nuse Mathielen\\ImportEngine\\Storage\\DoctrineStorage;\r\nuse Mathielen\\ImportEngine\\Storage\\LocalFileStorage;\r\nuse Mathielen\\ImportEngine\\Storage\\Format\\CsvFormat;\r\n\r\n$em = ... //Doctrine2 EntityManager\r\n\r\n$array = array(1,2,3);\r\n$storage = new ArrayStorage($array);\r\n$storage = new DoctrineStorage($em, 'MyEntities\\Entity');\r\n$storage = new LocalFileStorage('tests/metadata/testfiles/flatdata.csv', new CsvFormat());\r\n$storage = new ServiceStorage(array($service, 'myMethod')); //callable\r\n```\r\n\r\n### Validation\r\nYou can get the source and target validation errors with:\r\n```php\r\n$import = ...\r\n$import->importer()->validation()->getViolations();\r\n```\r\n\r\n#### Source data validation\r\n```php\r\nuse Mathielen\\ImportEngine\\Validation\\ValidatorValidation;\r\nuse Mathielen\\DataImport\\Filter\\ClassValidatorFilter;\r\nuse Symfony\\Component\\Validator\\Constraints\\NotBlank;\r\nuse Symfony\\Component\\Validator\\Constraints\\Regex;\r\n\r\n$validator = ... //Symfony Validator\r\n\r\n$validation = ValidatorValidation::build($validator)\r\n  ->addSourceConstraint('salutation', new NotBlank()) //source field 'salutation' should not be empty\r\n  ->addSourceConstraint('zipcode', new Regex(\"/[0-9]{5}/\")) //source field 'zipcode' should be 5 digits\r\n;\r\n```\r\n\r\n#### Target data Validation\r\n\r\n##### ClassValidatorFilter\r\nYou can use the ClassValidatorFilter to map the data to an object-tree and validate the objects (using annotations, or [differently configurated validation rules](http://symfony.com/doc/current/book/validation.html#constraint-configuration)). Therefore you must provide an ObjectFactory. There is a JmsSerializerObjectFactory you may want to use.\r\n\r\n```php\r\nuse Mathielen\\ImportEngine\\Validation\\ValidatorValidation;\r\nuse Mathielen\\DataImport\\Filter\\ClassValidatorFilter;\r\nuse Mathielen\\DataImport\\Writer\\ObjectWriter\\JmsSerializerObjectFactory;\r\n\r\n$validator = ... //Symfony Validator\r\n\r\n$jms_serializer = ... \r\n$objectFactory = new JmsSerializerObjectFactory(\r\n  'Entity\\Address',\r\n  $jms_serializer);\r\n\r\n$validation = ValidatorValidation::build($validator)\r\n  ->setTargetValidatorFilter(new ClassValidatorFilter($validator, $objectFactory));\r\n```\r\n\r\n### Importer\r\n```php\r\nuse Mathielen\\ImportEngine\\Importer\\Importer;\r\nuse Mathielen\\ImportEngine\\Storage\\ArrayStorage;\r\n\r\n$ffsp = ...\r\n$validation = ...\r\n$targetStorage = ...\r\n\r\n$array = array(1,2,3);\r\n$importer = Importer::build($targetStorage)\r\n  ->setSourceStorage(new ArrayStorage($array))\r\n  ->validation($validation)\r\n;\r\n```\r\n\r\n### Import / Source Storage\r\nYou can either use a StorageProvider (see above) and set the selection-id or you can use a specific Storage-Handler directly:\r\n```php\r\nuse Mathielen\\ImportEngine\\Storage\\ArrayStorage;\r\nuse Mathielen\\ImportEngine\\Storage\\LocalFileStorage;\r\nuse Mathielen\\ImportEngine\\Import\\Import;\r\nuse Mathielen\\ImportEngine\\Importer\\Importer;\r\nuse Mathielen\\ImportEngine\\Storage\\Format\\CsvFormat;\r\n\r\n$targetArray = array();\r\n$importer = Importer::build(new ArrayStorage($targetArray));\r\n$import = Import::build(\r\n    $importer,\r\n    new LocalFileStorage(new \\SplFileObject(__DIR__ . '/../../../metadata/testfiles/flatdata.csv'), new CsvFormat())\r\n);\r\n\r\n```\r\n\r\n### Mapping\r\nAlso see orginal documentation [here](https://github.com/ddeboer/data-import#mappingitemconverter).\r\n\r\n```php\r\n$import = ... \r\n\r\n$import->mappings()\r\n  ->add('foo', 'fooloo')\r\n  ->add('baz', array('some' => 'else'));\r\n;\r\n```\r\n\r\n### Converting fields\r\nThere are a some field-level build-in converters available:\r\n* upperCase\r\n* lowerCase\r\n* @TODO\r\n\r\n```php\r\n$import = ...\r\n\r\n$import->mappings()\r\n  ->add('SALUTATION_FIELD', 'salutation', 'upperCase')\r\n;\r\n```\r\n\r\n### Custom fieldlevel-converting\r\nYou have to register more complex converters to the importer for selecting them in your import.\r\n```php\r\nuse Mathielen\\ImportEngine\\Mapping\\Converter\\Provider\\DefaultConverterProvider;\r\nuse Ddeboer\\DataImport\\ValueConverter\\CallbackValueConverter;\r\nuse Mathielen\\ImportEngine\\Import\\Import;\r\nuse Mathielen\\ImportEngine\\Storage\\ArrayStorage;\r\nuse Mathielen\\ImportEngine\\Importer\\Importer;\r\n\r\n$converterProvider = new DefaultConverterProvider();\r\n$converterProvider\r\n  ->add('salutationToGender', new CallbackValueConverter(function ($item) {\r\n      switch ($item) {\r\n        case 'Mr.': return 'male';\r\n        case 'Miss':\r\n        case 'Mrs.': return 'femaile';\r\n      }\r\n  }));\r\n\r\n$targetStorage = ...\r\n\r\n$importer = Importer::build($targetStorage);\r\n$importer\r\n  ->transformation()\r\n  ->setConverterProvider($converterProvider);\r\n\r\n$array = array();\r\n$import = Import::build($importer, new ArrayStorage($array))\r\n  ->mappings()\r\n  ->add('salutation', 'gender', 'salutationToGender')\r\n;\r\n```\r\n\r\n### Custom rowlevel-converting\r\nLike the fieldlevel converters, you have to register your converters first.\r\n```php\r\nuse Mathielen\\ImportEngine\\Mapping\\Converter\\Provider\\DefaultConverterProvider;\r\nuse Ddeboer\\DataImport\\ItemConverter\\CallbackItemConverter;\r\nuse Mathielen\\ImportEngine\\Import\\Import;\r\nuse Mathielen\\ImportEngine\\Storage\\ArrayStorage;\r\nuse Mathielen\\ImportEngine\\Importer\\Importer;\r\n\r\n$converterProvider = new DefaultConverterProvider();\r\n$converterProvider\r\n  ->add('splitNames', new CallbackItemConverter(function ($item) {\r\n      list($firstname, $lastname) = explode(' ', $item['name']);\r\n\r\n      $item['first_name'] = $firstname;\r\n      $item['lastname'] = $lastname;\r\n\r\n      return $item;\r\n  }));\r\n\r\n$targetStorage = ...\r\n\r\n$importer = Importer::build($targetStorage);\r\n$importer\r\n  ->transformation()\r\n  ->setConverterProvider($converterProvider);\r\n\r\n$array = array();\r\n$import = Import::build($importer, new ArrayStorage($array))\r\n  ->mappings()\r\n  ->add('fullname', null, 'splitNames')\r\n;\r\n```\r\n\r\n### ImportRunner\r\nFor running a configured Import you need an ImportRunner. Internally the ImportRunner builds a workflow and runs it.\r\nYou can change the way how the workflow is built by supplying a different WorkflowFactory.\r\n\r\n```php\r\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\r\nuse Mathielen\\ImportEngine\\Import\\Run\\ImportRunner;\r\nuse Mathielen\\ImportEngine\\Import\\Workflow\\DefaultWorkflowFactory;\r\nuse Mathielen\\ImportEngine\\ValueObject\\ImportConfiguration;\r\nuse Mathielen\\ImportEngine\\Storage\\LocalFileStorage;\r\nuse Mathielen\\ImportEngine\\Storage\\Format\\CsvFormat;\r\nuse Mathielen\\ImportEngine\\Importer\\ImporterRepository;\r\n\r\n$import = ...\r\n\r\n$importRunner = new ImportRunner(new DefaultWorkflowFactory(new EventDispatcher()));\r\n\r\n//sneak peak a row\r\n$previewData = $importRunner->preview($import);\r\n\r\n//dont really write, just validate\r\n$importRun = $importRunner->dryRun($import);\r\n\r\n//do the import\r\n$importRun = $importRunner->run($import);\r\n```\r\n\r\n### ImportRun statistics\r\nIf you use the DefaultWorkflowFactory with your ImportRunner you get basic statistics from dryRun() and run() invocations.\r\n```php\r\n$importRun = ...\r\n$importRunner = ...\r\n\r\n$importRunner->dryRun($import);\r\n$stats = $importRun->getStatistics();\r\n\r\n/*\r\nArray\r\n(\r\n    [processed] => 1\r\n    [written] => 1\r\n    [skipped] => 0\r\n    [invalid] => 0\r\n)\r\n*/\r\n```\r\n\r\n### Eventsystem\r\nYou can interact with the running import via the [Symfony Eventdispatcher](http://symfony.com/doc/current/components/event_dispatcher/introduction.html).\r\n\r\n```php\r\nuse Symfony\\Component\\EventDispatcher\\EventDispatcher;\r\nuse Mathielen\\ImportEngine\\Import\\Run\\ImportRunner;\r\nuse Mathielen\\DataImport\\Event\\ImportProcessEvent;\r\nuse Mathielen\\DataImport\\Event\\ImportItemEvent;\r\nuse Mathielen\\ImportEngine\\Import\\Workflow\\DefaultWorkflowFactory;\r\n\r\n$myListener = function ($event) {\r\n    if ($event instanceof ImportItemEvent) {\r\n    \t$currentResult = $event->getCurrentResult(); //readonly access to current result in the process (might be false)\r\n    }\r\n};\r\n\r\n$eventDispatcher = new EventDispatcher();\r\n$eventDispatcher->addListener(ImportProcessEvent::AFTER_PREPARE, $myListener);\r\n$eventDispatcher->addListener(ImportItemEvent::AFTER_READ, $myListener);\r\n$eventDispatcher->addListener(ImportItemEvent::AFTER_FILTER, $myListener);\r\n$eventDispatcher->addListener(ImportItemEvent::AFTER_CONVERSION, $myListener);\r\n$eventDispatcher->addListener(ImportItemEvent::AFTER_CONVERSIONFILTER, $myListener);\r\n$eventDispatcher->addListener(ImportItemEvent::AFTER_VALIDATION, $myListener);\r\n$eventDispatcher->addListener(ImportItemEvent::AFTER_WRITE, $myListener);\r\n$eventDispatcher->addListener(ImportProcessEvent::AFTER_FINISH, $myListener);\r\n\r\n$workflowFactory = new DefaultWorkflowFactory($eventDispatcher);\r\n$importRunner = new ImportRunner($workflowFactory);\r\n\r\n$import = ...\r\n$importRunner->run($import);\r\n```\r\n\r\nLicense\r\n-------\r\n\r\nImport-Engine is released under the MIT license. See the [LICENSE](LICENSE) file for details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}